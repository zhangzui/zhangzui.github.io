<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes"/>
    <link href="./css/main.css" rel="stylesheet" type="text/css">
    <link href="./css/manni.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="./images/zz.jpg">
    <title></title>
</head>
<body>
<div class="not_in_mm">
    <div id="js_pc_qr_code" class="qr_code_pc_outer">
        <div class="qr_code_pc_inner">
            <div class="qr_code_pc_2">
                <img class="qr_code_pc_img" src="./images/myclass.jpg">
                <p>微信扫一扫<br>关注该公众号</p>
            </div>
        </div>
    </div>
</div>
  <div class="content">
  <h1>深入理解Java线程池：</h1>

<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>

<p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p>

<blockquote>
  <p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p>
</blockquote>

<p>所以线程池就出现了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>

<p>使用线程池的好处：
* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
* 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
* 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>

<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>

<h2>2、继承关系</h2>

<p>我们首先来看一下线程池的类图：
<img src="../../../image/threadPoolExecutor1.png" alt="" /></p>

<p><strong>Executor接口</strong></p>

<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Executor</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 在将来的某个时候执行传入的命令，执行命令可以在实现类里通过新创建的线程、线程池、当前线程来完成。</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p><strong>ExecutorService接口</strong></p>

<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ExecutorService</span> <span class="kd">extends</span> <span class="n">Executor</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">     * 启动先前提交的任务被执行的有序关闭，但不接受新的任务。 如果已经关闭，则调用没有其他影响。</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 尝试停止所有正在执行的任务，停止等待任务的处理，并返回正在等待执行的任务的列表。</span>
<span class="cm">     * 该方法不能等待之前提交的任务执行完，如果需要等待执行，可以使用{@link #awaitTermination awaitTermination}</span>
<span class="cm">     * 从这个方法返回后，这些任务从任务队列中排出（移除）。 除了竭尽全力地停止处理主动执行任务之外，没有任何保证。 </span>
<span class="cm">     */</span>
    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">shutdownNow</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 线程池有没有被关闭，关闭返回true，否则false</span>
<span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">isShutdown</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 如果所有任务在关闭后都完成了。返回true</span>
<span class="cm">     * 提示：如果没有在调用该方法前调用shutdown或者shutdownNow方法，此方法永远不会返回true</span>
<span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">isTerminated</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 在指定时间内阻塞等待任务全部完成，完成了返回true，否则false</span>
<span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">awaitTermination</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * 提交一个有返回值的任务</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">submit</span><span class="o">(</span><span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">task</span><span class="o">);</span>

    <span class="cm">/**</span>
<span class="cm">     * 提交一个任务来执行，返回一个有返回值的结果，返回值为传入的result</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">submit</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="n">T</span> <span class="n">result</span><span class="o">);</span>

    <span class="cm">/**</span>
<span class="cm">     * 提交一个任务来执行，返回一个有返回值的结果，返回值为null</span>
<span class="cm">     */</span>
    <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">submit</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">);</span>

    <span class="cm">/**</span>
<span class="cm">     * 执行一批有返回值的任务</span>
<span class="cm">     * 返回的结果调用{@link Future#isDone}都是true</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">invokeAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>
    <span class="cm">/**</span>
<span class="cm">     * 执行给定的任务，当全部完成或者超时返回一个有状态和结果的Future集合。</span>
<span class="cm">     * 返回的结果调用{@link Future#isDone}都是true</span>
<span class="cm">     * 返回时，尚未完成的任务将被取消。</span>
<span class="cm">     * 如果在进行此操作时修改了给定的集合，则此方法的结果是不确定的。</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">invokeAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">,</span>
                                  <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * 执行给定的任务，返回一个成功完成任务的结果（即，没有抛出异常），</span>
<span class="cm">     * 如果有的话。 在正常或异常返回时，尚未完成的任务将被取消。 </span>
<span class="cm">     * 如果在进行此操作时修改了给定的集合，则此方法的结果是不确定的。</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">T</span> <span class="nf">invokeAny</span><span class="o">(</span><span class="n">Collection</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">ExecutionException</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * 执行给定的任务，返回一个成功完成任务的结果（即，没有抛出异常），</span>
<span class="cm">     * 如果有的话。 在正常或异常返回时，尚未完成的任务将被取消。 </span>
<span class="cm">     * 如果在进行此操作时修改了给定的集合，则此方法的结果是不确定的。</span>
<span class="cm">     * 超时没有成功结果抛出TimeoutException</span>
<span class="cm">     */</span>
    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">T</span> <span class="nf">invokeAny</span><span class="o">(</span><span class="n">Collection</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">,</span>
                    <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">TimeoutException</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p><strong>AbstractExecutorService接口</strong></p>

<div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">RunnableFuture</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">runnable</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">RunnableFuture</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">callable</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">callable</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">T</span> <span class="nf">doInvokeAny</span><span class="o">(</span><span class="n">Collection</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">Callable</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">,</span>
                          <span class="kt">boolean</span> <span class="n">timed</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanos</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>


<h2>3、ThreadPoolExecutor分析</h2>

<p>想要深入理解ThreadPoolExecutor，就要先理解其中最重要的几个参数：</p>

<h3>3.1、核心变量与方法（状态转换）</h3>

<div class="highlight"><pre><span></span><span class="c1">// 状态|工作数的一个32bit的值</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="n">RUNNING</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNT_BITS</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span>
<span class="c1">// 0001-1111-1111-1111-1111-1111-1111-1111</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

<span class="c1">// 1110-0000-0000-0000-0000-0000-0000-0000</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="c1">// 0000-0000-0000-0000-0000-0000-0000-0000</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="c1">// 0010-0000-0000-0000-0000-0000-0000-0000</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="c1">// 0100-0000-0000-0000-0000-0000-0000-0000</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="c1">// 0110-0000-0000-0000-0000-0000-0000-0000</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>

<span class="c1">// ~CAPACITY就是前3位状态位，和c进行&amp;amp;就能得到当前的状态</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">~</span><span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>
<span class="c1">// 和c进行&amp;amp;就能得到当前的工作数</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>
<span class="c1">// rs就是状态值，wc就是工作数，这两个进行或操作，就能得到ctl的值（32bit的值）</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ctlOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">rs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">wc</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">rs</span> <span class="o">|</span> <span class="n">wc</span><span class="o">;</span> <span class="o">}</span>
</pre></div>


<p>可能很多人看到上面的写法都蒙圈了。我其实基础也不太好，所以我看到这里的时候索性写了个工具类去测试他们的输出结果，如下：</p>

<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExecutorTest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">COUNT_BITS</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;状态位===&quot;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">RUNNING</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">SHUTDOWN</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">STOP</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">TIDYING</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">TERMINATED</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getFormatStr</span><span class="o">(</span><span class="n">CAPACITY</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getFormatStr</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">integerMaxValueStr</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>
        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">integerMaxValueStr</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;</span> <span class="n">a</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(--</span><span class="n">l</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">integerMaxValueStr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;0&quot;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(++</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>输出结果为：</p>

<div class="highlight"><pre><span></span><span class="n">状态位</span><span class="o">===</span>
<span class="mi">1110</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span>
<span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span>
<span class="mo">0010</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span>
<span class="mo">0100</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span>
<span class="mo">0110</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span><span class="o">-</span><span class="mo">0000</span>
<span class="mo">0001</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span><span class="o">-</span><span class="mi">1111</span>
</pre></div>


<p>通过上面的注释以及测试用例可以发现，源码的作者巧妙的运用一个值代表了2种意思（前3bit位是状态，后29bit是工作数），下面我们来看看线程池最重要的5种状态：
* 1、RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；
* 2、SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；
* 3、STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；
* 4、TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
* 5、TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</p>

<p>下图为线程池的状态转换过程：
<img src="../../../image/threadPoolExecutor2.png" alt="" /></p>

<h3>3.2、构造方法</h3>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @param corePoolSize 保留在线程池中的线程数，即使它们处于空闲状态，除非设置了{@code allowCoreThreadTimeOut}</span>
<span class="cm"> * @param maximumPoolSize 线程池中允许的最大线程数</span>
<span class="cm"> * @param keepAliveTime 当线程数大于corePoolSize时，这是多余空闲线程在终止之前等待新任务的最大时间。</span>
<span class="cm"> * @param unit {@code keepAliveTime}参数的时间单位</span>
<span class="cm"> * @param workQueue 在执行任务之前用于保存任务的队列。 这个队列将只保存{@code execute}方法提交的{@code Runnable}任务。</span>
<span class="cm"> * @param threadFactory 用来执行的时候创建线程的线程工厂</span>
<span class="cm"> * @param handler 在执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
                          <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
                          <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
                          <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
                          <span class="n">BlockingQueue</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">workQueue</span><span class="o">,</span>
                          <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
                          <span class="n">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">corePoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">maximumPoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">maximumPoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">corePoolSize</span> <span class="o">||</span>
        <span class="n">keepAliveTime</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workQueue</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">threadFactory</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">handler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">corePoolSize</span> <span class="o">=</span> <span class="n">corePoolSize</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">maximumPoolSize</span> <span class="o">=</span> <span class="n">maximumPoolSize</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">workQueue</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">keepAliveTime</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">threadFactory</span> <span class="o">=</span> <span class="n">threadFactory</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>对于参数handler：线程池提供了4种策略：
* 1.AbortPolicy：直接抛出异常，这是默认策略；
* 2.CallerRunsPolicy：用调用者所在的线程来执行任务；
* 3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
* 4.DiscardPolicy：直接丢弃任务；</p>

<h3>3.3、核心方法</h3>

<p><strong>execute方法</strong></p>

<p>线程池最核心的方法莫过于execute了，execute()方法用来提交任务，下面我们顺着这个方法看看其实现原理：</p>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行</span>
<span class="cm"> * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="cm">/*</span>
<span class="cm">     * 执行分以下3步：</span>
<span class="cm">     *</span>
<span class="cm">     * 1. 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span>
<span class="cm">     *</span>
<span class="cm">     * 2. 如果线程入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的</span>
<span class="cm">     *</span>
<span class="cm">     * 3. 如果无法将任务入队列（可能队列满了），需要新开一个线程</span>
<span class="cm">     * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务。</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 1、如果当前线程数少于corePoolSize，开启一个线程执行命令</span>
<span class="cm">     *（可能是由于addWorker()操作已经包含对线程池状态的判断，如此处没加，而入workQueue前加了）</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="cm">/**</span>
<span class="cm">         * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()）</span>
<span class="cm">         * 失败的原因可能是：</span>
<span class="cm">         * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span>
<span class="cm">         * 2、workerCountOf(c) &amp;lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&amp;gt;=corePoolSize</span>
<span class="cm">         */</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 2、如果线程池RUNNING状态，且入队列成功</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span><span class="c1">//再次校验位</span>

        <span class="c1">//如果再次校验过程中，线程池不是RUNNING状态，并且remove(command)--workQueue.remove()成功，拒绝当前command</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="c1">// 新建一个worker线程，没有指定firstTask，因为命令已经放入queue里了</span>
            <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 3、如果线程池不是running状态 或者 无法入队列</span>
<span class="cm">     *   尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span>
<span class="cm">     */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p>在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：
* 1.如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；
* 2.如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；
* 3.如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；
* 4.如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p>

<p><strong>addWorker方法</strong></p>

<p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务。core为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * 检查是否可以针对当前的池状态和给定的界限（核心或最大值）添加新的工作者。相应地调整工人数量，并且如果可能的话，创建并开始新的工作者，运行firstTask作为其第一个任务。</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">retry</span><span class="o">:</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

        <span class="cm">/**</span>
<span class="cm">         * 只有当下面两种情况会继续执行，其他直接返回false（添加失败）</span>
<span class="cm">         * 1、rs == RUNNING</span>
<span class="cm">         * 2、rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; !workQueue.isEmpty() （执行了shutdown方法，但是阻塞队列还有任务没有执行）</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
            <span class="o">!</span> <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
               <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
               <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="c1">// 当wc超过最大限制 || 如果是核心线程，超过了核心数，否则超过了最大线程数，直接返回false</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">CAPACITY</span> <span class="o">||</span>
                <span class="n">wc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="o">(</span><span class="n">core</span> <span class="o">?</span> <span class="n">corePoolSize</span> <span class="o">:</span> <span class="n">maximumPoolSize</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                <span class="c1">// count累加成功，直接跳出两层for循环，执行下面的逻辑</span>
                <span class="k">break</span> <span class="n">retry</span><span class="o">;</span>

            <span class="cm">/**</span>
<span class="cm">             * 能执行到这里，都是因为多线程竞争，只有两种情况</span>
<span class="cm">             * 1、workCount发生变化，compareAndIncrementWorkerCount失败，这种情况不需要重新获取ctl，继续for循环即可。</span>
<span class="cm">             * 2、runState发生变化，可能执行了shutdown或者shutdownNow，这种情况重新走retry，取得最新的ctl并判断状态。</span>
<span class="cm">             */</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 重新读取ctl，可能状态发生了变化</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">)</span>
                <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
            <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 获取锁后重新检测runState，因为有可能shutdown了</span>
                <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">SHUTDOWN</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span>
                        <span class="c1">// 线程不能是活跃状态</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalThreadStateException</span><span class="o">();</span>
                    <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">largestPoolSize</span><span class="o">)</span>
                        <span class="n">largestPoolSize</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>    <span class="c1">//记录最大线程数</span>
                    <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workerAdded</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
            <span class="c1">// 失败回退,从 wokers 移除 w, 线程数减一，尝试结束线程池(调用tryTerminate 方法)</span>
            <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>注意一下这里的t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>

<p><strong>Worker类</strong></p>

<p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</p>

<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Worker</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span>
    <span class="n">Runnable</span> <span class="n">firstTask</span><span class="o">;</span>
    <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">completedTasks</span><span class="o">;</span>

    <span class="n">Worker</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">firstTask</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 还没有执行任务时，这时就不应该被中断，设置状态为-1</span>
        <span class="n">setState</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="n">firstTask</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">getThreadFactory</span><span class="o">().</span><span class="na">newThread</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 调用runWorker方法执行</span>
        <span class="n">runWorker</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Lock methods</span>
    <span class="c1">//</span>
    <span class="c1">// 0代表没有锁定状态</span>
    <span class="c1">// 1代表锁定状态</span>

    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>        <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span>      <span class="o">{</span> <span class="n">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">();</span> <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">interruptIfStarted</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：
* 1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中；
* 2.如果正在执行任务，则不应该中断线程；
* 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；
* 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；
* 5.之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</p>

<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p>

<p><strong>runWorker方法</strong></p>

<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>

<div class="highlight"><pre><span></span><span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="n">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="n">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span><span class="o">;</span>
    <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 允许中断</span>
    <span class="kt">boolean</span> <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 如果task为空，则通过getTask来获取任务</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">task</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">getTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">w</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>   <span class="c1">// 开始运行，不允许中断</span>

            <span class="cm">/**</span>
<span class="cm">             * 确保只有在线程STOP时，才会被设置中断标示，否则清除中断标示</span>
<span class="cm">             * 1、如果线程池状态&amp;gt;=STOP，且当前线程没有设置中断状态，wt.interrupt()</span>
<span class="cm">             * 2、如果一开始判断线程池状态&amp;lt;STOP，但Thread.interrupted()为true，即线程已经被中断，又清除了中断标示，再次判断线程池状态是否&amp;gt;=STOP</span>
<span class="cm">             *  是，再次设置中断标示，wt.interrupt()</span>
<span class="cm">             *  否，不做操作，清除中断标示后进行后续步骤</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">STOP</span><span class="o">)</span> <span class="o">||</span>
                 <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
                  <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">STOP</span><span class="o">)))</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
                <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span>
                <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 用户自己实现</span>
                <span class="n">beforeExecute</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">task</span><span class="o">);</span>
                <span class="n">Throwable</span> <span class="n">thrown</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 真正执行任务</span>
                    <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Error</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="c1">// 用户自己实现</span>
                    <span class="n">afterExecute</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">thrown</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">task</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">// worker已经完成的任务数 + 1</span>
                <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">++;</span>
                <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">processWorkerExit</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">completedAbruptly</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * getTask方法用来从阻塞队列中取任务</span>
<span class="cm"> * 以下情况会返回null</span>
<span class="cm"> * 1、超过了maximumPoolSize设置的线程数量（因为调用了setMaximumPoolSize()）</span>
<span class="cm"> * 2、线程池被stop</span>
<span class="cm"> * 3、线程池被shutdown，并且workQueue空了</span>
<span class="cm"> * 4、线程等待任务超时</span>
<span class="cm"> * 返回null表示这个worker要结束了，这种情况下workerCount-1</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="n">Runnable</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 上一次poll()是否超时</span>

    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

        <span class="cm">/**</span>
<span class="cm">         * 满足以下几点，wc - 1，返回null</span>
<span class="cm">         * 1、rs &amp;gt;= STOP</span>
<span class="cm">         * 2、rs == SHUTDOWN &amp;amp;&amp;amp; workQueue.isEmpty()</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">STOP</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">decrementWorkerCount</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

        <span class="c1">// 队列获取值是否要阻塞等待</span>
        <span class="c1">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span>
        <span class="c1">// wc &amp;gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span>
        <span class="c1">// 对于超过核心线程数量的这些线程，需要进行超时控制</span>
        <span class="kt">boolean</span> <span class="n">timed</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">||</span> <span class="n">wc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">corePoolSize</span><span class="o">;</span>

        <span class="cm">/**</span>
<span class="cm">         * 满足以下几点，wc - 1，返回null</span>
<span class="cm">         * 1、wc &amp;gt; maximumPoolSize</span>
<span class="cm">         * 2、1 &amp;lt; wc &amp;lt;= maximumPoolSize &amp;amp;&amp;amp; timed &amp;amp;&amp;amp; timedOut</span>
<span class="cm">         * 3、wc &amp;lt;= 1 &amp;amp;&amp;amp; workQueue.isEmpty() &amp;amp;&amp;amp; timed &amp;amp;&amp;amp; timedOut</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">wc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">maximumPoolSize</span> <span class="o">||</span> <span class="o">(</span><span class="n">timed</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">timedOut</span><span class="o">))</span>
            <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 获取Runnable</span>
            <span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">?</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">NANOSECONDS</span><span class="o">)</span> <span class="o">:</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">retry</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * @param completedAbruptly true：worker执行的时候异常了</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processWorkerExit</span><span class="o">(</span><span class="n">Worker</span> <span class="n">w</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 1、worker数量-1</span>
<span class="cm">     * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1</span>
<span class="cm">     * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">completedAbruptly</span><span class="o">)</span>
        <span class="n">decrementWorkerCount</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 2、从Workers Set中移除worker</span>
<span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 统计完成的任务数</span>
        <span class="n">completedTaskCount</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">;</span>
        <span class="c1">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span>
        <span class="n">workers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池</span>
<span class="cm">     * 主要是判断线程池是否满足终止的状态</span>
<span class="cm">     * 如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程</span>
<span class="cm">     * 没有线程了，更新状态为tidying-&amp;gt;terminated</span>
<span class="cm">     */</span>
    <span class="n">tryTerminate</span><span class="o">();</span>

    <span class="cm">/**</span>
<span class="cm">     * 4、是否需要增加worker线程</span>
<span class="cm">     * 线程池状态是running 或 shutdown</span>
<span class="cm">     * 如果当前线程是突然终止的，addWorker()</span>
<span class="cm">     * 如果当前线程不是突然终止的，但当前线程数量 &amp;lt; 要维护的线程数量，addWorker()</span>
<span class="cm">     * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="cm">/**</span>
<span class="cm">     * 以下情况会增加一个worker addWorker(null, false);</span>
<span class="cm">     * 1、completedAbruptly == true</span>
<span class="cm">     * 2、completedAbruptly == false &amp;amp;&amp;amp; allowCoreThreadTimeOut == true &amp;amp;&amp;amp; wc &amp;lt; 1</span>
<span class="cm">     * 3、completedAbruptly == false &amp;amp;&amp;amp; allowCoreThreadTimeOut == false &amp;amp;&amp;amp; wc &amp;lt; corePoolSize</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">runStateLessThan</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">STOP</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">corePoolSize</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">min</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span> <span class="c1">// replacement not needed</span>
        <span class="o">}</span>
        <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>getTask重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>

<p>processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束</p>

<p>下面是从execute到线程销毁的整个流程图：
<img src="../../../image/threadPoolExecutor3.png" alt="" /></p>

<h3>3.4、其他外部调用方法</h3>

<p>下面的方法都是用户可以自己进行调用的：</p>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * 状态改为SHUTDOWN</span>
<span class="cm"> * 启动先前提交的任务被执行的有序关闭，但不接受新的任务。 如果已经关闭，则调用没有其他影响。</span>
<span class="cm"> * 该方法不能等待之前提交的任务执行完，如果需要等待执行，可以使用{@link #awaitTermination awaitTermination}</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="n">SHUTDOWN</span><span class="o">);</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
        <span class="n">onShutdown</span><span class="o">();</span> <span class="c1">// hook for ScheduledThreadPoolExecutor</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 状态改为SHUTDOWN</span>
<span class="cm"> * 尝试停止所有正在执行的任务，停止等待任务的处理，并返回正在等待执行的任务的列表。 </span>
<span class="cm"> * 该方法不能等待之前提交的任务执行完，如果需要等待执行，可以使用{@link #awaitTermination awaitTermination}</span>
<span class="cm"> * 从这个方法返回后，这些任务从任务队列中排出（移除）。 除了竭尽全力地停止处理主动执行任务之外，没有任何保证。 </span>
<span class="cm"> * 这个实现通过{@link Thread＃interrupt}来取消任务，所以任何不能响应中断的任务都不会终止。</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">shutdownNow</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">tasks</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="n">STOP</span><span class="o">);</span>
        <span class="n">interruptWorkers</span><span class="o">();</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">drainQueue</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tasks</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 执行任务前的hook</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">beforeExecute</span><span class="o">(</span><span class="n">Thread</span> <span class="n">t</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>

<span class="c1">// 执行任务后的hook</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">afterExecute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 什么都不做，交给子类实现，注意实现的时候使用super.terminated();</span>
<span class="cm"> */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">terminated</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 判断状态 &amp;gt;= SHUTDOWN</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isShutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 判断 SHUTDOWN &amp;lt;= 状态 &amp;lt; TERMINATED</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isTerminating</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">return</span> <span class="o">!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">runStateLessThan</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">TERMINATED</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 判断状态 == TERMINATED</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isTerminated</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">TERMINATED</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 在指定的超时时间范围内等待状态变为TERMINATED</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">awaitTermination</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">nanos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">TERMINATED</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="mi">0</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">nanos</span> <span class="o">=</span> <span class="n">termination</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCorePoolSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">corePoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">corePoolSize</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">corePoolSize</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">corePoolSize</span> <span class="o">=</span> <span class="n">corePoolSize</span><span class="o">;</span>
    <span class="cm">/**</span>
<span class="cm">     * 1、当前workCount &amp;gt; 传入的corePoolSize，中断空闲worker</span>
<span class="cm">     * 2、传入的corePoolSize比之前的要大，选出差值和queue的大小做比较，比较小的作为要增加的线程数，调用addWorker，如果中途遇到workQueue为空，就不增加了。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">corePoolSize</span><span class="o">)</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">delta</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">delta</span><span class="o">,</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">k</span><span class="o">--</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 提前准备一个core的线程</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">prestartCoreThread</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">corePoolSize</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
        <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 提前准备所有的core线程</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">prestartAllCoreThreads</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
        <span class="o">++</span><span class="n">n</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 设置coreThreadTimeOut的值</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">allowCoreThreadTimeOut</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">keepAliveTime</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Core threads must have nonzero keep alive times&quot;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">allowCoreThreadTimeOut</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">allowCoreThreadTimeOut</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">)</span>
            <span class="n">interruptIdleWorkers</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 设置maximumPoolSize</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMaximumPoolSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">maximumPoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">maximumPoolSize</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">corePoolSize</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">maximumPoolSize</span> <span class="o">=</span> <span class="n">maximumPoolSize</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">maximumPoolSize</span><span class="o">)</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 从队列里面移除任务</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">removed</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
    <span class="n">tryTerminate</span><span class="o">();</span> <span class="c1">// In case SHUTDOWN and now empty</span>
    <span class="k">return</span> <span class="n">removed</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 清除队列里所有呗cancel的Future类型的任务，此方法可用作存储回收操作</span>
<span class="cm"> * 该方法可能存在其他线程的干扰，导致清除失败</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">purge</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">BlockingQueue</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="k">instanceof</span> <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">((</span><span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">r</span><span class="o">).</span><span class="na">isCancelled</span><span class="o">())</span>
                <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ConcurrentModificationException</span> <span class="n">fallThrough</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果在遍历期间遇到干扰，请采取慢速路径。进行遍历复制并调用remove取消条目。慢路径更可能是O（N * N）。</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">r</span> <span class="o">:</span> <span class="n">q</span><span class="o">.</span><span class="na">toArray</span><span class="o">())</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="k">instanceof</span> <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">((</span><span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">r</span><span class="o">).</span><span class="na">isCancelled</span><span class="o">())</span>
                <span class="n">q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">tryTerminate</span><span class="o">();</span> <span class="c1">// In case SHUTDOWN and now empty</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 返回线程池大小</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getPoolSize</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// runState == TIDYING 或者 runState == TERMINATED 返回0</span>
        <span class="c1">// 否则返回workers的大小</span>
        <span class="k">return</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">TIDYING</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span>
            <span class="o">:</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 获取活跃线程数：根据isLocked来判断是不是在执行任务</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getActiveCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">isLocked</span><span class="o">())</span>
                <span class="o">++</span><span class="n">n</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 返回最大线程池的大小</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLargestPoolSize</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">largestPoolSize</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 返回任务总数（包括已经完成的和未完成的）</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">long</span> <span class="nf">getTaskCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">completedTaskCount</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">isLocked</span><span class="o">())</span>
                <span class="o">++</span><span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 返回已完成任务总数</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCompletedTaskCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">completedTaskCount</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3>3.5、内部方法以及空方法</h3>

<p>下面的方法都是用户自己调用不了的方法，这里也做一下说明：</p>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * 替换状态</span>
<span class="cm"> * 如果现在的ctl状态 &amp;gt;= targetState，什么都不做</span>
<span class="cm"> * 如果现在的ctl状态 &amp;lt; targetState，尝试替换状态</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">advanceRunState</span><span class="o">(</span><span class="kt">int</span> <span class="n">targetState</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">targetState</span><span class="o">)</span> <span class="o">||</span>
            <span class="c1">// 前3位替换，后29位保持ctl原来的数目</span>
            <span class="n">ctl</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">ctlOf</span><span class="o">(</span><span class="n">targetState</span><span class="o">,</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">))))</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 尝试终止，只有当以下几种情况才把状态改为TERMINATED</span>
<span class="cm"> *      1、SHUTDOWN状态 &amp;amp;&amp;amp; queue是空的 &amp;amp;&amp;amp; wc == 0</span>
<span class="cm"> *      2、STOP状态 &amp;amp;&amp;amp; wc == 0</span>
<span class="cm"> * workCount如果不是0，这时候就中断其中一个idle的worker来传播关闭信号</span>
<span class="cm"> * 该方法必须在执行任何可能会终止的操作之后调用此方法 - 在关闭期间减少工作人员数量或从队列中删除任务。</span>
<span class="cm"> * ScheduledThreadPoolExecutor里面也用到了，所以这里修饰符没用private</span>
<span class="cm"> */</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryTerminate</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// c是运行时的状态</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">||</span>
            <span class="c1">// c的状态值 &amp;gt;= TIDYING</span>
            <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">TIDYING</span><span class="o">)</span> <span class="o">||</span>
            <span class="c1">// c的状态是SHUTDOWN &amp;amp;&amp;amp; 队列不是空</span>
            <span class="o">(</span><span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="c1">// worker数不是0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Eligible to terminate</span>
            <span class="n">interruptIdleWorkers</span><span class="o">(</span><span class="n">ONLY_ONE</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 设置ctl的状态为TIDYING，为中间过渡状态</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">ctlOf</span><span class="o">(</span><span class="n">TIDYING</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 终止方法，空方法什么都不做，子类去实现</span>
                    <span class="n">terminated</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="c1">// 设置ctl的状态为TERMINATED</span>
                    <span class="n">ctl</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="n">TERMINATED</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
                    <span class="n">termination</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 中断worker的空闲线程</span>
<span class="cm"> * @param onlyOne 是否仅仅中断worker中的第一个</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptIdleWorkers</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">onlyOne</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
            <span class="c1">// 尝试获取锁，这里只有当线程没有运行的时候才能够tryLock成功</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">w</span><span class="o">.</span><span class="na">tryLock</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 设置worker线程的中断变量</span>
                    <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// true，只中断队列的第一个就退出</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">onlyOne</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 中断所有worker的线程</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptWorkers</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span>
            <span class="n">w</span><span class="o">.</span><span class="na">interruptIfStarted</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 中断所有worker的空闲线程</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptIdleWorkers</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">interruptIdleWorkers</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 根据拒绝策略拒绝执行命令</span>
<span class="cm"> */</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">reject</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">handler</span><span class="o">.</span><span class="na">rejectedExecution</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 移除队列中的Runnable到一个新list中，使用的是阻塞队列的drainTo方法</span>
<span class="cm"> * 但是如果队列是DelayQueue或者其他能够让poll或者drainTo失败移除元素的队列的话，遍历队列并删除它</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">drainQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">BlockingQueue</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">;</span>
    <span class="n">ArrayList</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">taskList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Runnable</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">drainTo</span><span class="o">(</span><span class="n">taskList</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span> <span class="o">:</span> <span class="n">q</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">[</span><span class="mi">0</span><span class="o">]))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
                <span class="n">taskList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">taskList</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * 预留方法，ScheduledThreadPoolExecutor重写了此方法</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">onShutdown</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>

<span class="c1">// ScheduledThreadPoolExecutor进行调用，判断是不是running或shutdown状态</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isRunningOrShutdown</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">shutdownOK</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">rs</span> <span class="o">==</span> <span class="n">RUNNING</span> <span class="o">||</span> <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">shutdownOK</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ScheduledThreadPoolExecutor进行调用，确认都提前准备好了</span>
<span class="kt">void</span> <span class="nf">ensurePrestart</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">corePoolSize</span><span class="o">)</span>
        <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<h2>4、线程池的监控</h2>

<p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>

<ul>
<li>1.getTaskCount：线程池已经执行的和未执行的任务总数；</li>
<li>2.getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li>3.getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li>4.getPoolSize：线程池当前的线程数量；</li>
<li>5.getActiveCount：当前线程池中正在执行任务的线程数量。</li>
</ul>

<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>

<h2>5、合理的配置线程池</h2>

<p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>

<ul>
<li>1.任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>2.任务的优先级：高，中和低。</li>
<li>3.任务的执行时间：长，中和短。</li>
<li>4.任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>

<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>

<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>

<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>

<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>

<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>

<h2>6、结论</h2>

<p>本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：</p>

<ul>
<li>1.分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li>
<li>2.这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li>
<li>3.介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li>
<li>4.在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。</li>
</ul>

<p>在向线程池提交任务时，除了execute方法，还有一个submit方法，submit方法会返回一个Future对象用于获取返回值，有关Future和Callable请自行了解一下相关的文章，这里就不介绍了。</p>

<h2>参考</h2>

<p><a href="http://ifeve.com/java-threadpool/">聊聊并发（三）Java线程池的分析和使用</a> <br />
<a href="https://www.jianshu.com/p/d2729853c4da">深入理解Java线程池：ThreadPoolExecutor</a> <br />
<a href="https://www.cnblogs.com/trust-freedom/p/6681948.html">Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理</a></p>

  </div>
</body>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106796420-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());
  gtag('config', 'UA-106796420-1');
</script>

</html>